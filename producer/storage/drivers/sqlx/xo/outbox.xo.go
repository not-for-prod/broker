// Code generated by xo. DO NOT EDIT.
// Package generated contains the types for schema 'payout'.
package xo

import (
	"errors"
	"fmt"
	"reflect"
	"strings"
	"time"
)

// zeroOutbox zero value of dto
var zeroOutbox = Outbox{}

// Constants that should be used when building where statements
const (
	Alias_Outbox                         = "o"
	Table_Outbox_With_Alias              = "outbox AS o"
	Table_Outbox                         = "outbox"
	Field_Outbox_ID                      = "id"
	Field_Outbox_Topic                   = "topic"
	Field_Outbox_Partition               = "partition"
	Field_Outbox_Headers                 = "headers"
	Field_Outbox_Body                    = "body"
	Field_Outbox_TraceCarrier            = "trace_carrier"
	Field_Outbox_CreatedAt               = "created_at"
	Field_Outbox_ID_With_Alias           = "o.id"
	Field_Outbox_Topic_With_Alias        = "o.topic"
	Field_Outbox_Partition_With_Alias    = "o.partition"
	Field_Outbox_Headers_With_Alias      = "o.headers"
	Field_Outbox_Body_With_Alias         = "o.body"
	Field_Outbox_TraceCarrier_With_Alias = "o.trace_carrier"
	Field_Outbox_CreatedAt_With_Alias    = "o.created_at"
) // Outbox represents a row from 'outbox'.
type Outbox struct {
	ID           int64     `db:"id" json:"id"`                       // id
	Topic        string    `db:"topic" json:"topic"`                 // topic
	Partition    string    `db:"partition" json:"partition"`         // partition
	Headers      []byte    `db:"headers" json:"headers"`             // headers
	Body         []byte    `db:"body" json:"body"`                   // body
	TraceCarrier []byte    `db:"trace_carrier" json:"trace_carrier"` // trace_carrier
	CreatedAt    time.Time `db:"created_at" json:"created_at"`       // created_at

	// xo fields
	_exists, _deleted bool
}

type Outboxs []Outbox

func (t Outbox) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(o.id, %v) as id", zeroOutbox.ID),
		fmt.Sprintf("COALESCE(o.topic, '%v') as topic", zeroOutbox.Topic),
		fmt.Sprintf("COALESCE(o.partition, '%v') as partition", zeroOutbox.Partition),
		"o.headers",
		"o.body",
		"o.trace_carrier",
		fmt.Sprintf("COALESCE(o.created_at, '%v') as created_at", zeroOutbox.CreatedAt.Format(time.RFC3339)),
	}
}

func (t Outbox) SelectColumns() []string {
	return []string{
		"o.id",
		"o.topic",
		"o.partition",
		"o.headers",
		"o.body",
		"o.trace_carrier",
		"o.created_at",
	}
}

func (t Outbox) Columns(without ...string) []string {
	var str = "id, topic, partition, headers, body, trace_carrier, created_at"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t Outbox) WithTable(col string) string {
	return fmt.Sprintf("o.%s", col)
}

func (t Outbox) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroOutbox)
}

func (t Outbox) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("outbox AS o ON o.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *Outbox) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"id":            t.ID,
		"topic":         t.Topic,
		"partition":     t.Partition,
		"headers":       t.Headers,
		"body":          t.Body,
		"trace_carrier": t.TraceCarrier,
		"created_at":    t.CreatedAt,
	}
}

func (t *Outbox) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()
	if _, ok := m["updated_at"]; ok {
		m["updated_at"] = time.Now()
	}

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}

// Exists determines if the Outbox exists in the database.
func (o *Outbox) Exists() bool {
	return o._exists
}

// Deleted provides information if the Outbox has been deleted from the database.
func (o *Outbox) Deleted() bool {
	return o._deleted
}

// Insert inserts the Outbox to the database.
func (o *Outbox) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if o._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by sequence
	const sqlstr = `INSERT INTO outbox (` +
		`topic, partition, headers, body, trace_carrier, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`) RETURNING id`

	// run query
	XOLog(sqlstr, o.Topic, o.Partition, o.Headers, o.Body, o.TraceCarrier, o.CreatedAt)
	err = db.QueryRow(sqlstr, o.Topic, o.Partition, o.Headers, o.Body, o.TraceCarrier, o.CreatedAt).Scan(&o.ID)
	if err != nil {
		return err
	}

	// set existence
	o._exists = true

	return nil
}

// Update updates the Outbox in the database.
func (o *Outbox) Update(db XODB) error {
	var err error

	// sql query
	const sqlstr = `UPDATE outbox SET (` +
		`topic, partition, headers, body, trace_carrier, created_at` +
		`) = ( ` +
		`$1, $2, $3, $4, $5, $6` +
		`) WHERE id = $7`

	// run query
	XOLog(sqlstr, o.Topic, o.Partition, o.Headers, o.Body, o.TraceCarrier, o.CreatedAt, o.ID)
	_, err = db.Exec(sqlstr, o.Topic, o.Partition, o.Headers, o.Body, o.TraceCarrier, o.CreatedAt, o.ID)
	return err
}

// Save saves the Outbox to the database.
func (o *Outbox) Save(db XODB) error {
	if o.Exists() {
		return o.Update(db)
	}

	return o.Insert(db)
}

// Upsert performs an upsert for Outbox.
//
// NOTE: PostgreSQL 9.5+ only
func (o *Outbox) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if o._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO outbox (` +
		`id, topic, partition, headers, body, trace_carrier, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) ON CONFLICT (id) DO UPDATE SET (` +
		`id, topic, partition, headers, body, trace_carrier, created_at` +
		`) = (` +
		`EXCLUDED.id, EXCLUDED.topic, EXCLUDED.partition, EXCLUDED.headers, EXCLUDED.body, EXCLUDED.trace_carrier, EXCLUDED.created_at` +
		`)`

	// run query
	XOLog(sqlstr, o.ID, o.Topic, o.Partition, o.Headers, o.Body, o.TraceCarrier, o.CreatedAt)
	_, err = db.Exec(sqlstr, o.ID, o.Topic, o.Partition, o.Headers, o.Body, o.TraceCarrier, o.CreatedAt)
	if err != nil {
		return err
	}

	// set existence
	o._exists = true

	return nil
}

// Delete deletes the Outbox from the database.
func (o *Outbox) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !o._exists {
		return nil
	}

	// if deleted, bail
	if o._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM outbox WHERE id = $1`

	// run query
	XOLog(sqlstr, o.ID)
	_, err = db.Exec(sqlstr, o.ID)
	if err != nil {
		return err
	}

	// set deleted
	o._deleted = true

	return nil
}

func (o *Outboxs) Update(db XODB) error {
	var err error

	// sql insert query, primary key must be provided
	const sqlstr = `UPDATE outbox SET` +
		`id = t.id, ` +
		`topic = t.topic, ` +
		`partition = t.partition, ` +
		`headers = t.headers, ` +
		`body = t.body, ` +
		`trace_carrier = t.trace_carrier, ` +
		`created_at = t.created_at` +
		`FROM UNNEST(` +
		`$1::bigint[], ` +
		`$2::text[], ` +
		`$3::text[], ` +
		`$4::jsonb[], ` +
		`$5::jsonb[], ` +
		`$6::jsonb[], ` +
		`$7::timestamp with time zone[]` +
		`) as t(id, topic, partition, headers, body, trace_carrier, created_at)` +

		`WHERE id = t.id`

	batch := struct {
		ID           []int64     // id
		Topic        []string    // topic
		Partition    []string    // partition
		Headers      [][]byte    // headers
		Body         [][]byte    // body
		TraceCarrier [][]byte    // trace_carrier
		CreatedAt    []time.Time // created_at
	}{}

	for _, item := range *o {
		batch.ID = append(batch.ID, item.ID)
		batch.Topic = append(batch.Topic, item.Topic)
		batch.Partition = append(batch.Partition, item.Partition)
		batch.Headers = append(batch.Headers, item.Headers)
		batch.Body = append(batch.Body, item.Body)
		batch.TraceCarrier = append(batch.TraceCarrier, item.TraceCarrier)
		batch.CreatedAt = append(batch.CreatedAt, item.CreatedAt)
	}

	// run query
	_, err = db.Exec(
		sqlstr,
		batch.ID,
		batch.Topic,
		batch.Partition,
		batch.Headers,
		batch.Body,
		batch.TraceCarrier,
		batch.CreatedAt,
	)
	if err != nil {
		return err
	}

	return nil
}

func (o *Outboxs) Insert(db XODB) error {
	var err error

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO outbox (` +
		`topic, partition, headers, body, trace_carrier, created_at` +
		`) SELECT * FROM UNNEST(` +
		`$1::text[], ` +
		`$2::text[], ` +
		`$3::jsonb[], ` +
		`$4::jsonb[], ` +
		`$5::jsonb[], ` +
		`$6::timestamp with time zone[]` +
		`);`

	batch := struct {
		ID           []int64     // id
		Topic        []string    // topic
		Partition    []string    // partition
		Headers      [][]byte    // headers
		Body         [][]byte    // body
		TraceCarrier [][]byte    // trace_carrier
		CreatedAt    []time.Time // created_at
	}{}

	for _, item := range *o {
		batch.ID = append(batch.ID, item.ID)
		batch.Topic = append(batch.Topic, item.Topic)
		batch.Partition = append(batch.Partition, item.Partition)
		batch.Headers = append(batch.Headers, item.Headers)
		batch.Body = append(batch.Body, item.Body)
		batch.TraceCarrier = append(batch.TraceCarrier, item.TraceCarrier)
		batch.CreatedAt = append(batch.CreatedAt, item.CreatedAt)
	}

	// run query
	_, err = db.Exec(
		sqlstr,
		batch.ID,
		batch.Topic,
		batch.Partition,
		batch.Headers,
		batch.Body,
		batch.TraceCarrier,
		batch.CreatedAt,
	)
	if err != nil {
		return err
	}

	return nil
} // OutboxByID retrieves a row from 'outbox' as a Outbox.
// Generated from index 'outbox_pkey'.
func OutboxByID(db XODB, id int64) (*Outbox, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, topic, partition, headers, body, trace_carrier, created_at ` +
		`FROM outbox ` +
		`WHERE id = $1`

	// run query
	XOLog(sqlstr, id)
	o := Outbox{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&o.ID, &o.Topic, &o.Partition, &o.Headers, &o.Body, &o.TraceCarrier, &o.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &o, nil
}
