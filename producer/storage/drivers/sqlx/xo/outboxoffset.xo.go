// Code generated by xo. DO NOT EDIT.
// Package generated contains the types for schema 'payout'.
package xo

import (
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/pkg/errors"
)

// zeroOutboxOffset zero value of dto
var zeroOutboxOffset = OutboxOffset{}

// Constants that should be used when building where statements
const (
	Alias_OutboxOffset                         = "oo"
	Table_OutboxOffset_With_Alias              = "outbox_offset AS oo"
	Table_OutboxOffset                         = "outbox_offset"
	Field_OutboxOffset_ProducerName            = "producer_name"
	Field_OutboxOffset_Offset                  = "offset"
	Field_OutboxOffset_ProducerName_With_Alias = "oo.producer_name"
	Field_OutboxOffset_Offset_With_Alias       = "oo.offset"
) // OutboxOffset represents a row from 'outbox_offset'.
type OutboxOffset struct {
	ProducerName string `db:"producer_name" json:"producer_name"` // producer_name
	Offset       int64  `db:"offset" json:"offset"`               // offset

	// xo fields
	_exists, _deleted bool
}

type OutboxOffsets []OutboxOffset

func (t OutboxOffset) SelectColumnsWithCoalesce() []string {
	return []string{
		fmt.Sprintf("COALESCE(oo.producer_name, '%v') as producer_name", zeroOutboxOffset.ProducerName),
		fmt.Sprintf("COALESCE(oo.offset, %v) as offset", zeroOutboxOffset.Offset),
	}
}

func (t OutboxOffset) SelectColumns() []string {
	return []string{
		"oo.producer_name",
		"oo.offset",
	}
}

func (t OutboxOffset) Columns(without ...string) []string {
	var str = "producer_name, offset"
	for _, exc := range without {
		str = strings.Replace(str+", ", exc+", ", "", 1)
	}
	return strings.Split(strings.TrimRight(str, ", "), ", ")
}

func (t OutboxOffset) WithTable(col string) string {
	return fmt.Sprintf("oo.%s", col)
}

func (t OutboxOffset) IsEmpty() bool {
	return reflect.DeepEqual(t, zeroOutboxOffset)
}

func (t OutboxOffset) Join(rightColumnTable string, leftColumnTable string) string {
	return fmt.Sprintf("outbox_offset AS oo ON oo.%s = %s", rightColumnTable, leftColumnTable)
}

func (t *OutboxOffset) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"producer_name": t.ProducerName,
		"offset":        t.Offset,
	}
}

func (t *OutboxOffset) Values(colNames ...string) (vals []interface{}) {
	m := t.ToMap()
	if _, ok := m["updated_at"]; ok {
		m["updated_at"] = time.Now()
	}

	for _, v := range colNames {
		vals = append(vals, m[v])
	}

	return vals
}

// Exists determines if the OutboxOffset exists in the database.
func (oo *OutboxOffset) Exists() bool {
	return oo._exists
}

// Deleted provides information if the OutboxOffset has been deleted from the database.
func (oo *OutboxOffset) Deleted() bool {
	return oo._deleted
}

// Insert inserts the OutboxOffset to the database.
func (oo *OutboxOffset) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if oo._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO outbox_offset (` +
		`producer_name, offset` +
		`) VALUES (` +
		`$1, $2` +
		`)`

	// run query
	XOLog(sqlstr, oo.ProducerName, oo.Offset)
	_, err = db.Exec(sqlstr, oo.ProducerName, oo.Offset)
	if err != nil {
		return err
	}

	// set existence
	oo._exists = true

	return nil
}

// Update updates the OutboxOffset in the database.
func (oo *OutboxOffset) Update(db XODB) error {
	var err error

	// sql query
	const sqlstr = `UPDATE outbox_offset SET (` +
		`offset` +
		`) = ( ` +
		`$1` +
		`) WHERE producer_name = $2`

	// run query
	XOLog(sqlstr, oo.Offset, oo.ProducerName)
	_, err = db.Exec(sqlstr, oo.Offset, oo.ProducerName)
	return err
}

// Save saves the OutboxOffset to the database.
func (oo *OutboxOffset) Save(db XODB) error {
	if oo.Exists() {
		return oo.Update(db)
	}

	return oo.Insert(db)
}

// Upsert performs an upsert for OutboxOffset.
//
// NOTE: PostgreSQL 9.5+ only
func (oo *OutboxOffset) Upsert(db XODB) error {
	var err error

	// if already exist, bail
	if oo._exists {
		return errors.New("insert failed: already exists")
	}

	// sql query
	const sqlstr = `INSERT INTO outbox_offset (` +
		`producer_name, offset` +
		`) VALUES (` +
		`$1, $2` +
		`) ON CONFLICT (producer_name) DO UPDATE SET (` +
		`producer_name, offset` +
		`) = (` +
		`EXCLUDED.producer_name, EXCLUDED.offset` +
		`)`

	// run query
	XOLog(sqlstr, oo.ProducerName, oo.Offset)
	_, err = db.Exec(sqlstr, oo.ProducerName, oo.Offset)
	if err != nil {
		return err
	}

	// set existence
	oo._exists = true

	return nil
}

// Delete deletes the OutboxOffset from the database.
func (oo *OutboxOffset) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !oo._exists {
		return nil
	}

	// if deleted, bail
	if oo._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM outbox_offset WHERE producer_name = $1`

	// run query
	XOLog(sqlstr, oo.ProducerName)
	_, err = db.Exec(sqlstr, oo.ProducerName)
	if err != nil {
		return err
	}

	// set deleted
	oo._deleted = true

	return nil
}

func (oo *OutboxOffsets) Update(db XODB) error {
	var err error

	// sql insert query, primary key must be provided
	const sqlstr = `UPDATE outbox_offset SET` +
		`producer_name = t.producer_name, ` +
		`offset = t.offset` +
		`FROM UNNEST(` +
		`$1::text[], ` +
		`$2::bigint[]` +
		`) as t(producer_name, offset)` +

		`WHERE producer_name = t.producer_name`

	batch := struct {
		ProducerName []string // producer_name
		Offset       []int64  // offset
	}{}

	for _, item := range *oo {
		batch.ProducerName = append(batch.ProducerName, item.ProducerName)
		batch.Offset = append(batch.Offset, item.Offset)
	}

	// run query
	_, err = db.Exec(
		sqlstr,
		batch.ProducerName,
		batch.Offset,
	)
	if err != nil {
		return err
	}

	return nil
}

func (oo *OutboxOffsets) Insert(db XODB) error {
	var err error

	// sql insert query, primary key must be provided
	const sqlstr = `INSERT INTO outbox_offset (` +
		`producer_name, offset` +
		`) SELECT * FROM UNNEST(` +
		`$1::text[], ` +
		`$2::bigint[]` +
		`);`

	batch := struct {
		ProducerName []string // producer_name
		Offset       []int64  // offset
	}{}

	for _, item := range *oo {
		batch.ProducerName = append(batch.ProducerName, item.ProducerName)
		batch.Offset = append(batch.Offset, item.Offset)
	}

	// run query
	_, err = db.Exec(
		sqlstr,
		batch.ProducerName,
		batch.Offset,
	)
	if err != nil {
		return err
	}

	return nil
} // OutboxOffsetByProducerName retrieves a row from 'outbox_offset' as a OutboxOffset.
// Generated from index 'outbox_offset_pkey'.
func OutboxOffsetByProducerName(db XODB, producerName string) (*OutboxOffset, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`producer_name, offset ` +
		`FROM outbox_offset ` +
		`WHERE producer_name = $1`

	// run query
	XOLog(sqlstr, producerName)
	oo := OutboxOffset{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, producerName).Scan(&oo.ProducerName, &oo.Offset)
	if err != nil {
		return nil, err
	}

	return &oo, nil
}
